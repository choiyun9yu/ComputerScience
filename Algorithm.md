[Algorithm with C](https://github.com/choiyun9yu/C/tree/main/Algorithm.md)

# 검색 알고리즘

## 1. 선형 검색 알고리즘 $O(n)$ 
- 맨 앞 또는 맨 뒤부터 순서대로 살펴보면서 원하는 데이터를 찾는 방법

## 2. 이진 검색 알고리즘 $O(\log_2 n)$
(선행 조건: 순서대로 정렬이 되어 있어야 한다.)
- 전체 데이터를 두 부류로 나눈 뒤 조건을 만족하는 데이터에서만 찾는 방법
- $1$ 이하의 데이터가 남을 때까지 절반으로 나누면서 탐색

#### $\log$ 
$\log n$ 은 밑을 몇번 곱하면 $n$이 되는지 나타낼 때 사용한다.  
(밑을 생략하면, 수학에선 보통 $\log_10$인데 컴퓨터 공학에서는 $\log_2$를 의미)  
$n$을 $2$로 $\log n$번 나누면 $1$이 된다. 

## 3. 해시 검색 알고리즘 $O(1)$
- key값을 해시 함수에 넣어서 나온 해시 값을 인덱스로 사용해서 해시 테이블에 저장한다.  
*해시 테이블: 해시법에서 데이터를 보관하는 곳
- 검색할 때 key값을 넣으면 해시 함수가 해시값을 반환하고 해시 테이블에서 찾아서 값을 찾는다.

#### 해시 충돌
해시 충돌은 서로 다른 key에서 해시 함수로 구한 해시 값이 같은 경우를 말한다.
- 오픈 주소법: 이미 해시 값 인덱스에 데이터가 들어가 있으면 이웃한 빈 공간에 데이터를 채워넣는다.   
  검색 시 이웃한 데이터도 같이 검색한다.
- 체인법: 이미 해시 값 인덱스에 데이터가 들어가 있으면 공간을 연결할 자리를 만든다.  
  검색 시 연결된 공간도 같이 검색한다.


<br>

# 정렬 알고리즘
정렬은 데이터값을 크기 순서로 배열하는 것이다. 배열이 이중 구조일 때는 안쪽 배열의 데이터를 1번째 데이터 부터 차례로 비교한다. 만약 1번째 데이터가 같다면 2번째 데이터를 비교한다.

정렬하고자 하는 순서와 반대로 정렬되어 있는 경우 가장 느리다.

### 빅오 표기법
- 계수는 생략한다.
- 주요 항만 남긴다.
- 보통 최악을 기준으로 표기한다.
- 1회 비교할 때 걸리는 시간을 a, 1회 이동할 때 걸리는 시간을 b라고 할 때 빅오 표기법 계산 방법
  $a \times 비교횟수 + b \times 이동횟수$

![image](https://github.com/choiyun9yu/ComputerScience/assets/110392046/82fb4a31-b5bd-46b2-b721-68f30d5d9e1b)

### 보초법(sentinel method)
보초법은 프로그램을 빠르게 만들어주는 방법 중 하나이다. 어떤 조건을 만족하는 데이터를 검색할 때 그 조건을 만족하는 것으로 보이는 데이터를 미리 배열 끝에 추가하면 배열 끝에 도달하는 과정을 생량할 수 있어서 프로그램의 처리 속도가 빨라진다.

보초법을 사용하지 않으면 검색하고 있는 데이터가 찾고자하는 데이터인지 확인하는 동시에 지금 검색하고 있는 데이터가 배열 밖인지도 확인해야한다. 찾고자하는 데이터가 배열 안에 없으면 배열 밖으로 나가기 때문이다. 그러나 검색을 시작하기 전에 배열의 끝에 찾고자하는 데이터를 넣어두면 반드시 데이터를 반드시 찾을 수 있으므로 배열 밖으로 나갔는지 나가지 않을지 확인하지 않아도 된다.

보초법은 삽입 정렬이나 퀵 정렬 같은 정렬 알고리즘에서 사용한다.

<br>

## 1. 삽입 정렬 [최선: $O(n)$ / 최악: $O(n^2)$]
삽입 정렬은 데이터를 앞에서 또는 뒤에서 하나씩 살펴본 뒤 적절한 위치에 삽입하고 정렬하는 방식이다. **정렬 대상인 데이터의 수가 적을 때 사용**한다. 

삽입 정렬은 앞이든 뒤든 한 축을 정렬 완료 축으로 잡고 하나씩 비교 하면서 정렬 완료의 범위에 하나씩 삽입해가며 정렬한다. 

### 1-1. 삽입 정렬의 데이터 비교 횟수 [최소: $n - 1$회 / 최대: $\frac{1}{2}(n - 1) \times (1 + (n - 1))$회]

삽입 정렬이 최선일 경우 데이터 비교 횟수는 $n - 1$회 이다. 최초 축이 되는 자신을 제외한 데이터와 1번씩만 비교하기 때문이다.

이를 빅오 표기봅으로 나타내면 아래와 같다.

>$n - 1$   
>$→ n$   
>$→ O(n)$

반면 삽입 정렬이 최악일 경우 데이터 비교 횟수는 한 번 정렬할 때마다 정렬 완료된 데이터 바로 옆에 위치한 데이터가 정렬 완료된 데이터 모두와 비교한다.

|정렬된 데이터 수|비교 횟수|
|------------|------|
|$1$|$1$|
|$2$|$2$|
|$3$|$3$|
|$...$|$...$|
|$n - 2$|$n - 2$|
|$n - 1$|$n - 1$|

데이터 비교는 최초에는 정렬완료된 데이터가 1개 뿐이라서 1회만 비교해도 되지만 마지막에는 n-1개의 데이터와 비교해야한다.

이제 우리는 총 비교 횟수를 구하기 위해서 $1$부터 $n-1$까지의 숫자의 합을 구해야한다. 이때 가우스 덧셈법으로 계산하면 $\frac{1}{2}(n - 1) \times (1 + (n - 1))$이다.

이를 빅오 표기법으로 정리하면 아래와 같다.  

>$\frac{1}{2}n(n - 1)$
>$= \frac{1}{2}n^2 - \frac{1}{2}n$
>$→ n^2 + n$    
>$→ n^2$        
>$→ O(n^2)$

### 1-2. 삽입 정렬의 데이터 이동 횟수 [최소: $0$회 / 최악: $\frac{1}{2}(n - 1) \times (n + 1))$회]
삽입 정렬이 최선일 경우 데이터 이동 횟수가 0회이다. 삽입 정렬이 최악일 경우는 데이터가 역으로 정렬되어 있을 때이고, 이때 데이터 이동 횟수는 $\frac{1}{2}(n + 1)n - 1$이다.

최악일 경우 데이터는 정렬 할 때마다, 정렬 완료된 모든 데이터가 움직이고 새로 삽입되는 데이터도 이동해야하기 때문에 정렬 완료된 데이터 $+1$번 이동한다.

|정렬된 데이터 수|이동 횟수|
|------------|------|
|$1$|$2$|
|$2$|$3$|
|$3$|$4$|
|$...$|$...$|
|$n - 2$|$n - 1$|
|$n - 1$|$n$|

이제 우리는 총 이동 횟수를 구하기 위해서 $2$부터 $n$까지의 숫자의 합을 구해야한다. 이때 가우스 덧셈법으로 계산하면 $\frac{1}{2}(n - 1) \times (n + 1))$이다.

이를 빅오 표기법으로 정리하면 아래와 같다.

>$\frac{1}{2}(n + 1)n - 1$
>$= \frac{1}{2}n^2 + \frac{1}{2}n - 1$
>$→ n^2 + n +1$  
>$→ n^2$        
>$→ O(n^2)$

### 1-3. 삽입 정렬의 시간 복잡도
> $a \times \frac{1}{2}n(n - 1) + b \times \frac{1}{2}(n + 1)n - 1$  
> $= \frac{a}{2}n^2 - \frac{a}{2}n + \frac{b}{2}n^2 + \frac{b}{2}n - b$  
> $= (\frac{a}{2} + \frac{b}{2})n^2 = (\frac{a}{2} - \frac{b}{2})n - b$  
> $→ n^2 + n + 1$  
> $→ n^2$  
> $→ O(n^2)$

<br>

## 2. 선택 정렬 [최선: $O(n)$ / 최악: $O(n^2)$]
선택 정렬은 남아있는 데이터 가운데 가장 작은 값 또는 가장 큰 값처럼 가장 적합한 값을 찾아서 찾아서 남은 배열 끝에 있는 데이터와 위치를 바꾸면서 정렬한다.

선택은 Selection인데 이 단어에는 '도태'라는 뜻도 담겨있다. 선택 정렬에서 가장 적당한 데이터를 꺼내는 방식은 마치 도태되는 과정과도 비슷하다.

그럼 가장 작은 값 혹은 가장 큰 값은 어떻게 구할까? 맨 앞에 있는 데이터를 복사해두고 차례대로 조사하면서 더 작거나 더 큰 값이 나오면 복사해둔 값을 갱신하는 식으로 찾는다.

### 2-1. 선택 정렬의 데이터 비교 횟수 [고정: $\frac{1}{2}n(n - 1)$회]

최솟값을 찾기위한 비교 횟수는 데이터가 $n$개 일 때 비교 횟수는 $n-1$번 이다. 최초 데이터 1개를 조사할 때에는 비교를 하지 않기 때문이다.

|남은 데이터 수|비교 횟수|
|-------|------|
|$n$|$n - 1$|
|$n-1$|$n - 2$|
|$...$|$...$|
|$3$|$2$|
|$2$|$1$|

우리는 선택 정렬을 총 $n-1$번 하고 $1$부터 $n - 1$까지 더해야한다. 이를 빅오 표기법으로 나타내면 앞서 삽입 정렬에서 살펴보았듯이 $O(n^2)$이다.

선택 정렬은 비교 횟수가 항상 $O(n^2)$이다.

### 2-2. 선택 정렬의 데이터 교환 횟수 [최소: 0회 / 최대: $n-1$회]

삽입 정렬의 경우 데이터 이동 횟수를 구했지만 선택 정렬에서는 데이터가 이동할 때 반드시 데이터가 있는 자리를 바꾸게 된다. 따라서 선택 정렬에서는 데이터 이동 횟수가 아니라 데이터 교환 횟수를 구한다.

데이터 교환 횟수가 가장 적을 때는 당연히 0번이다. 반대로 데이터 교환 횟수가 가장 많을 때에는 정렬 마다 교환이 발생해서 $n-1$회 교환이 발생한다.

### 2-3. 선택 정렬의 시간 복잡도

> $a \times \frac{1}{2}n(n - 1) + b \times (n - 1)$  
> $= \frac{a}{2}n^2 - \frac{a}{2}n +b - b$  
> $= \frac{a}{2}n^2 - (\frac{a}{2} - b)n - b$  
> $→ n^2 + n + 1$  
> $→ n^2$  
> $→ O(n^2)$

<br>

## 3. 버블 정렬 [고정: $O(n^2)$]
버블 정렬은 이웃한 데이터를 비교 및 교환하며 정렬한다. 따라서 최악의 경우 데이터를 비교할 때마다 교환하게 된다. 

### 3-1. 버블 정렬의 데이터 비교 횟수 
선택 정렬과 같은 방법으로 계산할 수 있다. 버블 정렬은 비교 횟수도 항상 $O(n2)$이다.

### 3-2. 버블 정렬의 데이터 교환 횟수 
**버블 정렬은 비교 때마다 교환이 일어나기 때문에 교환 횟수가 선택 정렬보다 많다.**  
(최악일 경우 버블 정렬의 교환 횟수는 $O(n^2)$이지만 선택 정렬의 경우 교환 횟수는 $O(n)$이다.)

<br>

## 4. 퀵 정렬 [최선: $O(n \log n)$ / 최악: $O(n^2)$]
퀵 정렬은 기준값, 즉 피벗(pivot)이라는 값의 크기에 따라 작은 데이터와 큰 데이터로 분류하는 작업을 반복해서 정렬하는 알고리즘이다. **데이터를 빠르게 정리해서 인기가 많은 방식이다.**

오름 차순 정렬시 피벗보다 작은 데이터는 왼쪽으로 모으고, 피벗보다 큰 데이터는 오른쪽으로 보낸다. 다음 퀵 정렬에서 왼쪽과 오른쪽에서 각각 다시 피벗을 정하고 반복한다.(이는 재귀함수로 구현한다.) 

#### 퀵 정렬에서 기준 값을 선택하는 여러가지 방법
퀵 정렬은 기준 값을 선택하는 방법에 따라 데이터 정렬의 효율이 달라진다. 기준값의 크기에 따라 데이터를 2개로 나눴을 때 각각 절반에 가깝게 할당하면 정렬에서 효율이 좋아진다.
- 맨 앞과 중간 그리고 마지막 데이터를 기준값으로 정하는 방법
- 여러 데이터를 크기 순으로 나열했을 때 중앙값을 기준으로 정하는 방법
- 무작위로 선택한 데이터를 기주능로 정하는 방법 등이 있다.

#### 나눠서 정렬하는 전략 - 분할 정복 알고리즘
퀵 정렬과 병합 정렬에서는 입력 데이터를 나눠서 작게 정리한 다음에 정렬한다. 이렇게 데이터를 더 작게 나눠서 정리하는 알고리즘을 분할 정복이라고 한다.

분할 정복 알고리즘을 적절하게 사용하면 데이터를 빠르게 처리할 수 있다. 여기서 핵심은 문제를 작게 나눠서 해결한 결과가 어떤 형태로 기록하고 이용되는가이다. 

예를 들어 데이터들끼리 비교해서 도출한 결과가 존재하는 데이터 조합에서는 반복해서 비교하지 않도록 정렬 알고리즘을 설계하면 정렬 시간을 단축할 수 있다.

### 4-1. 퀵 정렬의 데이터 비교 횟수 [최소: $O(n \log n)$회 / 최대: $O(n^2)$회]

#### 퀵 정렬이 최상일 경우 데이터 비교 횟수 $O(n \log n)$
최상의 경우는 매 정렬 시마다 데이터를 약절반으로 나눌 수 있는 값을 피벗으로 삼는 것이다. $\log_2$는 &n&을 절반으로 몇 번 나누면 $1$이 되는지 나타낸다. 데이터가 1개 이하가 되면 정렬할 필요가 없으므로 데이터가 1개 이하기 될 때까지 절반으로 나누면 된다. 따라서 $\log_2n - 1$회 정렬하면 모든 데이터가 1개 이하로 나뉘게 된다.

실제 비교는 피벗을 기준으로 양옆을 비교하게 되지만 계산을 쉽게하기 위해 피벗에 대해서도 조사를 한다고 가정하면 각 정렬마다 비교하는 횟수는 n번이다. 

따라서 총 비교 횟수는 $n \times n \log n$이라고 할 수 있다.

> $n \times (n \log n - 1)$
> $= n \log n - n$
> $→ n \log n$
> $→ O(n \log n)$ 

#### 퀵 정렬이 최악일 경우 데이터 비교 횟수 $O(n^2)$
최악의 경우는 퀵 정렬은 데이터의 가장 극단적인 값을 피벗 값으로 지정해 피벗값 이외의 나머지 데이터를 한쪽으로 모는 것이다. 이 경우 퀵 정렬의 정렬 횟수는 데이터가 1개 남았을 때를 제외한 $n - 1$회이고 n-1회이다.

퀵 정렬은 각 정렬마다 피벗값과 나머지 정렬할 값을 비교하게 된다. 

|누적 퀵 정렬 횟수|비교 횟수|
|-------------|------|
|$1$|$n - 1$|
|$2$|$n - 2$|
|$3$|$n - 3$|
|$...$|$...$|
|$n - 2$|$2$|
|$n - 1$|$1$|

> $\frac{1}{2}n(n - 1)$
> $= \frac{1}{2}n^2 - \frac{1}{2}n$
> $→ n^2 + n$
> $→ n^2$
> $→ O(n^2)$

### 4-2. 퀵 정렬의 데이터 교환 횟수
데이터를 교환하는 횟수가 필연적으로 데이터를 비교하는 횟수보다 적기 때문에 데이터를 비교하는 횟수만으로 시간 복잡도를 구한다.

### 4-4. 퀵 정렬의 순서
- 첫 번째 데이터를 기준값으로 시작
- 왼쪽에서부터 기준값보다 큰 데이터를 찾고, 오른쪽에서부터 기준값보다 작은 데이터 탐색
- 찾으면 두 데이터 교환
- 두 데이터가 엇갈리는 경우에는 기준값과 작은 데이터의 위치를 서로 변경
- 기준값을 기준으로 왼쪽과 오른쪽에서 다시 퀵 정렬을 수행하는 과정 반복
- 확인할 데이터가 1개일 때 종료

<br>

## 5. 안정된 정렬
안정된 정렬은 중복되는 값은 입력된 순서대로 정렬한다. 불안정 정렬은 중복된 값이 입려된 순서와 상관없이 정렬된다.

예를 들어 먼저 A라는 기준으로 정렬하고 이후 B라는 기준으로 정렬하면 안정된 정렬은 B를 기준으로 정렬하고 같은 값의 경우 A를 기준으로 정렬되지만 불안정 정렬은 B를 기준으로 정렬되고 A기준은 보장하지 않는다.

대표적인 안정된 정렬은 삽입 정렬, 버블 벙렬, 병합 정렬이 있고, 대표적인 불안정 정렬은 퀵 정렬, 선택 정렬, 계수 정렬이 있다.

<br>

## 6. 병합 정렬 [고정: $O(n \log n)$]
병합 정렬은 데이터가 1개 남을 때까지 열을 2개로 나누는 작업을 반복한 후 병합하는 작업을 반복하면서 데이터를 정렬한다. 

병합 정렬은 퀵 정렬에 비해 컴퓨터 메모리를 많이 사용하는 알고리즘으로 부정적으로 소개되기도 하지만 시간 복잡도가 일정하고 규모가 작으며 안정된 정렬 알고리즘이다.

### 6-1. 병합 정렬의 시간 복잡도
병합 정렬은 최상일 때와 최악일 때 모두 시간 복잡도는 O(n \log n)으로 같다.

데이터를 1개 남을 때 까지 2개의 열로 계속 나누기 때문에 병합 정렬은 $log_2n$번 정렬하고, 각 정렬마다 데이터는 n회 이동한다. 

따라서 총 데이터 이동 횟수는 $\log_2 n \time n$이다.

> $\log n \times n$  
> $= n \log n$

<br>
<br>
<br>

# 암호화 알고리즘

<br>
<br>
<br>

# 문제 해결 알고리즘 (PSS, Problem Solving Strategies_

## 1. 반복 전략(Loop Algorithm)
반복 전략은 루프(for, while등의 반복문) 속에서 조건이 충족될 때 까지 절차를 반복하는 것이다.

### 1-1. 중첩 루프와 멱집합
*멱집합; 어떤 집합의 원소로 만들 수 있는 모든 부분 집합을 의미

### 1-2. 재귀를 이용한 반복
재귀 알고리즘은 반복 알고리즘에 비해 간결하고 이해하기 쉽다는 장점이 있다. 그러나 재귀 알고리즘이 실행되면 수많은 자기 복제본이 만들어지고, 계산 비용이 별도로 발생한다. 완료되지 않은 재귀 호출과 중간 계산 과정을 계속 추적해야하기 때문이다. 

만약 성능을 취대한 높여야 하는 상황이라면 재귀 알고리즘을 순수한 반복형태로 수정해서 추가 비용이 발생하지 않도록 하는 것이 좋다. 

## 2. 완전 탐색(Brute Force)
완전 탐색은 답이 될 수 있는 후보를 전부 조사하여 문제를 해결하는 가장 무식하면서도 확실한 방법이다.

## 3. 역추적(Backtracking)
완전 탐색에서 정답이 될 수 없는 후보를 제거하여 불필요한 탐색을 줄여 효율성을 높인 문제 해결 방법이다.

## 4. 발견법(Heuristic)
직관에 의해 최고는 아니더라도 충분히 좋은 답을 찾는 방법이다. 완전 탐색이나 역추적 전략 사용시 시간이 너무 많이 걸릴 때 사용한다.

### 4-1. 탐욕법(Greedy Algorithm)
탑욕법은 이전의 선택으로 절대 돌아가지 않는다. 각 단계마다 최선의 선택을 추구하되, 일단 선택하고 나면 과거의 선택을 되돌아보지 않는 것이다.

완벽한 답을 구하는 전통적인 알고리즘 대신 발견법을 사용하면 답을 빨리 구할 수 는 있지만 정확성이 떨어지는 점을 감수해야한다. 그러나 작금의 선택이 미래에 영향을 끼치지 않는 경우에는 탐욕법과 완전탐색으로 얻은 답이 일치한다.

## 5. 분할 정복(Divide and Conquer)
이 전략은 최적 부분 구조로 구성된 문제를 해결하기에 적합하다. 최적 부분 구조로 구성된 문제란 비슷한 형태의 더 작은 부분 문제로 문제를 나눌 수 있는 문제를 말한다. 이렇게 나뉜 부문 문제 역시 같은 방식으로 계속 나눌 수 있다. 계속 나누다 보면 결국 쉽게 풀 수 있는 간단한 문제가 된다. 이 간단한 문제들의 답을 각각 구한 뒤 서로 결합하면 원래 문제의 답을 구할 수 있게 된다.

## 6. 동적 계획법(Dynamic Programming)
문제를 풀 때, 동일한 연산이 여러 차례 수행되는 경우가 있다. 동적 계획법을 활용하면 반복되는 부분 문제를 식별하여 이들을 한 번씩만 연산할 수 있다. 이를 위해 메모이즈라는 기법을 활용한다.


## 7. 분기 한정법
최적화 문제에서 구하려는 답이 '선택의 연속'일 때 자주 활용되는 전략이다. 나쁜 선택지를 빠르게 제거해서 시간을 절약할 수 있다. 

문제를 풀다보면 '차선의 답'을 쉽게 구할 수 있을 때가 많다. 이런 답은 최적해에 다가가는 범위를 설정한다. 차선의 답보다 안좋으면 버리고, 좋으면 범위를 좁혀나가는 방식으로 문제를 해결한다.


1) 문제를 여러 개의 부분 문제로 나눈다.
2) 각 부분 문제의 상한과 하한을 구한다
3) 각 부분문제에서 모든 분기의 상한, 하한 범위를 비교한다.
4) 가장 유망한 부분 문제를 선택하여 1단계로 돌아간다.
