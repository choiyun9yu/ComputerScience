# Object-Oriented Programming
- 객체 지향 프로그래밍은 이 세상에 존재하는 모든 것을 객체로 상정한다.
- 이 객체는 클래스라고 하는 일종의 설계도에 의해서 만들어지며, 실제로 구현된 객체를 인스턴스라고 한다.

## 1. 객체 지향의 특징
### 1-1. 추상화(Abstraction)
- OOP를 사용하여 프로그램을 만들 때 대부분 실생활에 존재하는 객체들을 기반으로 프로그램의 객체들을 형성한다.
- 그러나 프로그램의 객체들이 실존하는 객체들을 100% 정확하게 구현하지 않는다.
- 대신 프로그램의 객체들은 특정 맥락에서 객체의 필드와 메서드를 모델링하고 나머지는 무시한다.
- 이 때 특정 맥락에 해당하는 것들을 추려내는 것을 추상화라고 할 수 있다. 

### 1-2. 캡슐화(Encapsulation)
- 자동차 엔진을 시동하려면 시동 버튼을 누르기만 하면 된다.
- 시동을 걸기위한 세세한 작업들은 자동차 후드 아래 숨겨져 있고 운전자에게는 시동 버튼이라는 단순한 인터페이스만 제공될 뿐이다.  
  이것은 객체가 인터페이스를 갖는 방식과 비슷하다.
- 인터페이스는 다른 객체와 상호작용할 수 있는 객체의 공개된 부분이다.
- 캡슐화는 객체가 그 상태와 행동의 일부를 다른 객체들로부터 숨기고 나머지 프로그램에는 제한된 인터페이스만 노출할 수 있는 기능이다.
######
- 무언가를 캡슐화 한다는 것은 그것을 private로 만든다는 뜻이다.
- 그러면 그 무언가는 자신의 클래스의 메서드 내에서만 접근할 수 있게된다.
- 조금 덜 제한적인 protected 접근 제한자는 멤버를 자식 클래스에서도 사용할 수 있게 해준다.
- 간단히 말해 속성과 기능을 하나로 묶어서 필요한 기능을 메소드를 통해 외부로 제공하는 것을 캡슈로하라고 한다.
- 캡슐 내부의 변경이 있다고 하더라도 외부에서 가져다 사용하는 인터페이스가 같으면 사용하는측의 코드는 수정할 필요 없다.

### 1-3. 다형성(Ploymorphism)
- 다형성은 다양한 형태 or 여러 형태를 의미한다.
- 프로그램에서 다형성은 한 객체가 여러 타입의 객체로 취급될 수 있는 능력을 뜻한다.
- 보통 하나의 객체는 하나의 타입으로 고정되어 있다.
- 그러나 다형성을 사용하면 하나의 객체가 다른 타입으로 사용될 수 있다.

### 1-4. 상속 관계(Inheritance)
- 상속은 기존클래스의 필드와 메서드를 새로운 클래스에서 재사용하게 해주는 것을 말한다.

### 1-5. 은닉화(Hiding)
- 객체의 데이터와 메서드를 외부에서 직접 접근하지 못하도록 제한하는 것을 말한다.

<br>

## 2. 객체 지향의 5원칙(SOLID)

### 2-1. SRP(Single Responsibility Principle, 단일 책임 원칙)
> **하나의 객체는 반드시 하나의 동작만 책임**져야 한다.

- 모듈화가 강해질수록 다른 객체와의 의존성/연관성이 줄어든다.
- 반대로 이야기하면 모듈화가 약해질수록 다른 객체와의 의존/연관성은 크게 늘어난다.
- 최악의 경우 어떠한 은닉화 정책도 존재하지 않아 모듈의 메소드에 무분별하게 접근할 수도 있게 된다.
######
- 객체가 담당하는 동작. 즉, 책임이 많아질수록 해당 객체의 변경에 따른 영향도의 양과 범위가 매우 커진다.
- 단일 책임 원칙은 특정 객체의 책임 의존성 과중을 최대한 지양하기 위한 원칙이다.

### 2-2. OCP(Open Close Principle, 개방-폐쇄 원칙)
> 객체를 다룸에 있어서 **객체의 확장은 개방적으로, 객체의 수정은 폐쇄적으로** 대해야 한다.

- 기능의 변경이나 확장은 가능하지만, 해당 기능의 코드는 수정하면 안된다는 뜻이다.
- 예를 들어, 객체 하나를 수정한다고 가정할 때 단순히 해당 객체만 수정하는 것이 아니라
  해당 객체에 의존하는 다른 객체들의 코드까지 줄줄이 고쳐야한다면 좋은 설계가 아니다.
- 이처럼 개방-폐쇄 원칙은 각 객체의 모듈화와 정보 은닉의 올바른 구현을 추구하며,
  이를 통해 객체 간의 의존성을 최소화하여 코드 변경에 따른 영향력을 낮추기 위한 원칙이다.

### 2-3. LSP(Liskov Substitution Principle, 리스코프 치환 원칙)
> **부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체**할 수 있어야 한다.

- 객체지향 언어에선 객체의 상속이 일어난다. 이 과정에서 부모/자식 관계가 정의된다.
- 자식 객체는 부모 객체의 특성을 가지며, 이를 토대로 확장할 수 있다.
- 하지만 이 과정에서 무리하거나 객체의 의의와 어긋나는 확장으로 인해 잘못된 방향으로 상속되는 경우도 있다.
- 이 원칙은 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙이다.

### 2-4. ISP(Interface Segregaion Principle, 인터페이스 분리 원칙)
> **객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다.**

- 구현할 객체에게 무의미한 메소드의 구현을 방지하기 위해 반드시 필요한 메소드만을 상속/구현하도록 권고한다.
- 만약 상속할 객체의 규모가 너무 크다면, 해당 객체의 메소드를 작은 인터페이스로 나누는 것이 좋다.

![image](https://github.com/choiyun9yu/ComputerScience/assets/110392046/cdac4b3c-3ca2-4695-ba7a-14f6c8a401bd)

- 위 그림에서 왼쪽 객체는 메소드 1,2,3 을 모두 사용하지만, 오른쪽 객체는 메소드 1만 필요하다.
- 이런 경우 인터페이스 1,2,3 으로 쪼개서 필요한 만큼만 상속/구현하는 것이 좋다.

### 2-5. DIP(Dependency Inversion Principle, 의존성 역전 원칙)
> **객체는 저수준 모듈보다 고수준 모듈에 의존해야 한다.**

*고수준 모듈: 인터페이스와 같은 객체의 형태나 추상적 개념
*저수준 모듈: 구현된 객체

- 위 원칙은 객체는 객체보다 인터페이스에 의존해야한다는 순화 시킬 수 있다. 
- 가급적 객체의 상속은 인터페이스와 같은 추상적이고 범용적인 것을 통해 이루어져야 한다고 이해할 수 있다.


