# ProblemSolvingStrategies

## 1. 반복 전략(Loop Algorithm)
반복 전략은 루프(for, while등의 반복문) 속에서 조건이 충족될 때 까지 절차를 반복하는 것이다.

### 1-1. 중첩 루프와 멱집합
*멱집합; 어떤 집합의 원소로 만들 수 있는 모든 부분 집합을 의미

### 1-2. 재귀를 이용한 반복
재귀 알고리즘은 반복 알고리즘에 비해 간결하고 이해하기 쉽다는 장점이 있다. 그러나 재귀 알고리즘이 실행되면 수많은 자기 복제본이 만들어지고, 계산 비용이 별도로 발생한다. 완료되지 않은 재귀 호출과 중간 계산 과정을 계속 추적해야하기 때문이다. 

만약 성능을 취대한 높여야 하는 상황이라면 재귀 알고리즘을 순수한 반복형태로 수정해서 추가 비용이 발생하지 않도록 하는 것이 좋다. 

## 2. 완전 탐색(Brute Force)
완전 탐색은 답이 될 수 있는 후보를 전부 조사하여 문제를 해결하는 가장 무식하면서도 확실한 방법이다.

## 3. 역추적(Backtracking)
완전 탐색에서 정답이 될 수 없는 후보를 제거하여 불필요한 탐색을 줄여 효율성을 높인 문제 해결 방법이다.

## 4. 발견법(Heuristic)
직관에 의해 최고는 아니더라도 충분히 좋은 답을 찾는 방법이다. 완전 탐색이나 역추적 전략 사용시 시간이 너무 많이 걸릴 때 사용한다.

### 4-1. 탐욕법(Greedy Algorithm)
탑욕법은 이전의 선택으로 절대 돌아가지 않는다. 각 단계마다 최선의 선택을 추구하되, 일단 선택하고 나면 과거의 선택을 되돌아보지 않는 것이다.

완벽한 답을 구하는 전통적인 알고리즘 대신 발견법을 사용하면 답을 빨리 구할 수 는 있지만 정확성이 떨어지는 점을 감수해야한다. 그러나 작금의 선택이 미래에 영향을 끼치지 않는 경우에는 탐욕법과 완전탐색으로 얻은 답이 일치한다.

## 5. 분할 정복(Divide and Conquer)
이 전략은 최적 부분 구조로 구성된 문제를 해결하기에 적합하다. 최적 부분 구조로 구성된 문제란 비슷한 형태의 더 작은 부분 문제로 문제를 나눌 수 있는 문제를 말한다. 이렇게 나뉜 부문 문제 역시 같은 방식으로 계속 나눌 수 있다. 계속 나누다 보면 결국 쉽게 풀 수 있는 간단한 문제가 된다. 이 간단한 문제들의 답을 각각 구한 뒤 서로 결합하면 원래 문제의 답을 구할 수 있게 된다.

## 6. 동적 계획법(Dynamic Programming)
문제를 풀 때, 동일한 연산이 여러 차례 수행되는 경우가 있다. 동적 계획법을 활용하면 반복되는 부분 문제를 식별하여 이들을 한 번씩만 연산할 수 있다. 이를 위해 메모이즈라는 기법을 활용한다.


## 7. 분기 한정법
최적화 문제에서 구하려는 답이 '선택의 연속'일 때 자주 활용되는 전략이다. 나쁜 선택지를 빠르게 제거해서 시간을 절약할 수 있다. 

문제를 풀다보면 '차선의 답'을 쉽게 구할 수 있을 때가 많다. 이런 답은 최적해에 다가가는 범위를 설정한다. 차선의 답보다 안좋으면 버리고, 좋으면 범위를 좁혀나가는 방식으로 문제를 해결한다.


1) 문제를 여러 개의 부분 문제로 나눈다.
2) 각 부분 문제의 상한과 하한을 구한다
3) 각 부분문제에서 모든 분기의 상한, 하한 범위를 비교한다.
4) 가장 유망한 부분 문제를 선택하여 1단계로 돌아간다.