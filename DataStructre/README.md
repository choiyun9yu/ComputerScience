# Data Structure
자료구조는 프로그램에서 사용할 많은 데이터를 메모리 상에서 관리하는 여러 구현 방법들이다. 효율적인 자료구조가 성능 좋은 알고리즘의 기반이 된다.

## 1. 선형 데이터

### 1-1. List
유연한 방식으로 데이터를 다루고 싶을 때, 아무 위치에서나 요소를 추가, 제거하고 싶을 때 사용
- insert(i, e): e 요소를 인덱스 i 에 추가
- remove(i): 인덱스 i 위치의 요소를 제거
- get(i): 인덱스 i 위치의 요소를 제거
- slice(start, end): start 이상 end 미만 사이 요소로 리스트 분리
- sort( ): 리스트 정렬
- reverse( ): 리스트 역정렬

### 1-2. Linked List
각 노드는 데이터와 다음 노드를 가리키는 포인터로 구성된 자료 구조
- 장점  
  배열 처럼 연속된 저장 공간을 필요로하지 않는다.  
  데이터 추가 삭제할 때 데이터를 옮기지 않고 포인터만 수정하면된다.

### 1-3. Doubly Linked List
각 노드가 데이터와 이전 노드 그리고 다음 노드를 가리키는 포인트로 구성된 자료 구조

### 1-4. Stack(LIFO)
- push(e): 요소 e를 스택의 가장 위에 추가
- pop( ): 스택의 가장 위의 요소를 가져오고 그 요소를 스택에서 제거

### 1-5. Queue(FIFO)
- enqueue(e): 요소 e를 큐의 가장 뒤에 추가
- dequeue( ): 큐의 가장 앞 요소를 가져오고 그 요소를 큐에서 제거

### 1-6. Priority Queue
각 요소가 우선순위를 가지고 있고, 해당 우선순위에 따라 요소가 처리되는 자료구조  
우선순위 큐는 일반적으로 높은 우선순위를 가진 요소가 먼저 처리하고,  
동일한 우선순위를 가진 경우 먼저 삽입된 요소를 먼저 처리

### 1-7. Deque, Double Ended Queue
양쪽 끝에서 삽입과 삭제가 모두 가능한 큐

### 1-8. Hash Table
해싱은 해시 함수를 사용해 키와 값을 해시 테이블에 매핑하는 자료구조
(요소에 대한 빠른 접근 가능)

### 1-9. Map, Dictionary
key와 value로 데이터를 저장할 때 사용
- set(key, value): key-value 쌍을 추가
- delete(key): key 와 key에 연관된 value 삭제
- get(key): key 와 연관된 value 조회

### 1-10. Set
요소의 순서가 무의미하고 요소가 중복되지 않아야 할 때 사용
- add(e): 요소 e 를 집합에 추가, 이미 존재하는 경우 오류 발생
- list( ): 집합의 요소 나열
- delete(e): 집합에서 요소 e 를 제거

<br>

## 2. 비선형 데이터

### 2-1. Tree
연결 리스트 처럼 다른 칸을 향한 포인터 저정하는 자료 구조  
연결 리스트와 다른 점은 한 줄의 사슬 형태가 아닌 나무 형태
- 트리 구조의 3가지 조건  
  닫힌 회로가 없어야 한다. 즉, 시작 점과 끝 점이 서로 연결 되어 있어야 한다.  
  루트 노드, 부모 노드, 리프 노드는 에지(가지)로 연결 되어야 한다.  
  부모 노드와 리프 노드는 각각 에지 1개와 끝 점 1개로 연결 되어야 한다.

### 2-2. BST, Binary Search Tree
각 노드가 최대 두 개의 자식 노드를 가지면서, 왼쪽 서브트리의 모든 노드는 모든 노드는 현재 노드보다 작고,  
오른쪽 서브 트리의 모든 노드는 현재 노드보다 큰 값을 갖는 이진 트리

        5
       / \
      3   8
     / \   \
    2   4   9


### 2-3. Graph
트리와 비슷하지만 부모, 자식 노드가 없고 루트 노드도 없는 자료 구조
모든 노드는 다른 노드를 가리키는 간선을 여러개 가질 수 있는 자료 구조

### 2-4. Heap
특정한 규칙을 가진 이진 트리로 구성된 자료 구조  
일반적으로 최대 힙 또는 최소 힙으로 사용, 힙은 주로 우선순위 큐와 같은 자료 구조를 구현하는데 사용

### 2-5. Priority Heap


### 2-6. Binary Heap


<br>
<br>
<br>

# Algorithm
Algorithm은 주어진 문제를 풀기 위한 단게적 절차이다. 즉 알고리즘을 설계한다는 것은 문제 풀이 절차를 설계한다는 것이고, 알고리즘을 구현한다는 것은 프로그래밍 언어를 이용해서 문제 풀이 절차를 실제로 동작하는 코드로 작성한다는 의미이다.

## 1. 탐색

### 1-1. 선형 탐색
맨 앞 또는 맨 뒤부터 순서대로 살펴보면서 원하는 데이터를 찾는 방법

### 1-2. 이진 탐색
> 선행 조건: 순서대로 정렬이 되어 있어야 한다.

전체 데이터를 두 부류로 나눈 뒤 조건을 만족하는 데이터에서만 찾는 방법  
$1$ 이하의 데이터가 남을 때까지 절반으로 나누면서 탐색

### 1-3. 해쉬 탐색
> 선행조건: key 값을 해시 함수에 넣어서 나온 해시 값을 인덱스로 사용해서 해시 테이블에 저장한다.

검색할 때 key 값을 넣으면 해시 함수가 해시값을 반환하고 해시 테이블에서 찾아서 값을 찾는 방법

<br>

## 2. 정렬

### 2-1. 삽입 정렬
데이터 앞 또는 뒤에서 하나씩 살펴본 뒤 적절한 위치에 삽입하면서 정렬 영역을 넓혀 가는 방법

### 2-2. 선택 정렬
남아 있는 데이터 가운데 가장 작거나 큰 값 처럼 적절한 값을 찾아서 남은 배열 끝에 있는 데이터와 위치를 바꾸면서 정렬하는 방법

### 2-3. 버블 정렬
이웃한 데이터를 비교 및 교환하여 정렬하는 방법

### 2-4. 퀵 정렬
피벗이라는 기준 값을 기준으로 작은 데이터와 큰 데이터로 분류하는 작업을 반복하며 정렬하는 방법

### 2-5. 병합 정렬
분할 정복 알고리즘 중 하나로 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 방법  
하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법

<br>

## 3. 알고리즘 설계 기법

### 3-1. 알고리즘 성능 분석

### 3-2. 루프(반복)
반복문 안에서 문제가 해결될 때까지 절차를 반복하는 방법

### 3-3. 브루트 포스(완전 탐색)
답이 될 수 있는 후보를 전부 조사하여 문제를 해결하는 방법

### 3-4. 백트랙킹(역 추적)
답이 될 수 없는 후보를 제거하며 불필요한 탐색을 줄여 효율성을 높인 방법

### 3-5 휴리스틱
직관에 의해 최고는 아니더라도 충분히 좋은 답을 찾는 방법    
(완전 탐색이나 역추적 전략 사용시 시간이 너무 많이 걸릴 때 사용)

### 3-5. 그리디(탐욕법)
휴리스틱 알고리즘의 한 종류이다. 직관에 의해 최고는 아니더라도 충분히 좋은 답을 찾는 방법  
각 단계마다 최선의 선택을 추구하되, 일단 선택하고 나면 과거의 선택으로 돌아가지 않는 방법

### 3-6. 분할 정복
큰 문제를 더 작은 문제로 계속 나누다가 쉽게 풀 수 있는 간단한 문제의 답을 각각 구한 뒤 서로 결합하면서 원래 문제의 답을 구하는 방법
(비슷한 형태의 더 작은 부분 문제로 나눌 수 있는 최적-부분 구조로 된 문제를 해결할 때 적합)

### 3-7. 다이나믹 프로그래밍(동적 계획법)
어떤 문제를 풀기 위해 그 문제를 더 작은 문제의 연장선으로 생각하고, 과거에 구한 해를 활용하는 방법  
(문제를 풀 때, 동일한 연산이 여러 차례 반복 수행될 때 적합, 최적-부분 구조로 된 문제를 해결할 때 적합)
- 메모라이제이션(하향식 접근법)
- 타뷸레이션(상향식 접근법)

### 3-8. 분기 한정법
문제를 풀다 보면 '차선의 답'을 쉽게 구할 수 있을 때가 많다. 이런 답은 최적해에 다가가는 범위를 설정하고 차선의 답보다 안좋으면 버리고 좋으면 범위를 좁혀나가는 방식으로 문제를 해결하는 방법
(최적화 문제에서 구하려는 답이 '선택의 연속'일 때 적합, 나쁜 선택지를 빠르게 제거해서 시간을 절약)