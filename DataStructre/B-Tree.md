# Balanced Tree

## 1. What is B Tree?
![image](https://github.com/user-attachments/assets/b18acceb-f0b0-40ad-9ca9-47a0c1fa9d74)
- B-Tree 는 데이터베이스와 파일 시스템에서 널리 사용되는 트리 자료구조의 일종이다.
- 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조이다.
- 즉, 하나의 노드에 하나의 데이터를 저장하는 다른 Self-Balanced Tree 와 달리,  
  하나의 노드에 여러개의 데이터를 저장하는 방식으로 Tree 의 height 를 줄여 탐색 시간을 더 획기적으로 줄이도로 고안되었다.
- 이렇게 고안된 트리를 유지하기 위한 몇가지 규칙이 있다.

### 1-1.B-Tree 규칙 
- 노드 안에 k 개의 데이터가 있다면 자식 노드 수는 k+1 개여야 한다.  
  ex) 첫번째 노드의 데이터 갯수를 2개로 잡았다면, 그 자식 노드의 수는 3개여야 한다.
- 노드 안 데이터는 정렬되어야 한다.  
  ex) 한 노드 안의 데이터는 오름차순으로 정렬되어야 한다.
- 자식 노드의 데이터는 부모 노드의 데이터에 따라 배치된다.  
  ex) 부모 노드의 데이터를 기준으로 자식 노드를 정렬하여 나눈다. 예시로 1 ~ 8의 값에 대해, 부모 노드의 데이터가 3,6이 들어간다면  
  ![image](https://github.com/user-attachments/assets/ba9fd9dc-5c0c-4e43-adb9-bf309a3813c4)    
  이런 형태로 자식 노드는 3보다 작은 값, 3과 6 사이 값, 6보다 큰 값으로 이루어진 3개의 자식 노드가 생긴다.
- 루트 노드가 리프 노드가 아닌 경우 항상 2개 이상의 자식을 갖는다.
- M차 B-Tree 라면 루트 노드와 리프 노드를 제외하고 최소 M/2개 이상의 데이터를 가지고 있어야 한다.  
  (최대 M 개의 자식을 가질 수 있는 B-Tree 를 M차 B-Tree 라고 한다.)
- 리프 노드의 데이터 수는 M 보다 작아야 한다. (리프 노드 최대 데이터 수는 M-1 개이다.)
- 모든 리프 노드의 높이는 같아야 한다.

  
### 1-2. B-Tree 의 연산
#### 탐색
- B-Tree 는 탐색 시 루트 노드에서부터 하향식으로 탐색한다.
- 자식 노드의 데이터는 부모 노드의 데이터에 따라 오름차순으로 배치되므로, 이를 활용한 대소비교를 통해 알맞은 브랜치를 따라 값을 찾을 때까지 하향하며 탐색한다.

#### 삽입
- B-Tree 의 삽입 과정은 탐색과 달리 리프 노드에서부터 상향식으로 찾이간다.
- 데이터를 넣을 적절한 리프 노드를 탐색하여 노드에 값을 삽입하면 되는데, 이때 주의할 점은 "리프 노드의 데이터 수는 M보다 작아야한다"를 만족시켜야 한다는 것이다.  
  노드에 들어있는 데이터 수가 M-2 이하라면 그냥 삽입하면 되지만, M-1 이라면 값이 삽입될 시 데이터 수가 M 이 되면서 B-Tree 의 조건을 위배하기 때문이다.  
  이 경우 해당 값을 부모 노드로 올리며 그 자식 노드들은 새로 분리해준다. 이 과정을 B-Tree 의 조건을 만족할 때까지 재귀적으로 수행한다.

#### 삭제 
- 노드를 삭제하는 과정은 조금 더 복잡한데, 삭제 시 B-Tree 의 조건인 아래 3가지를 만족하도록 트리를 재구조화 해야한다.
  - 루트 노드와 리프 노드를 제외한 노드는 2개 이상의 자식을 가져야 한다.
  - 각 노드는 M/2~ M-1 개의 데이터를 가질 수 있다.
  - 각 노드의 데이터 수가 k 라면 자식 노드의 수는 k+1 이어야 한다.
- 이때 경우에 따라 값이 삭제된 노드의 나머지 데이터를 분할하거나, 부모 노드로 올린 뒤 나머지 자식 노드를 B-Tree 의 조건에 맞게 재배치하는 작업이 필요하다.
- 만약 현재 노드와 자식 노드가 모두 데이터 수가 최소 인 경우, 트리의 높이를 줄여야할 수도 있다.
- 삭제된 데이터의 자식 노드를 합치고 부모 노드를 내려 이를 자식으로 연결하는 등의 재구조화가 필요하다.


### 1-3. B*Tree
- B*Tree 는 균형을 유지하기 위한 연산에서 노드의 생성과 부가적인 연산을 최소화하기 위해 등장하게 되었다.
- 기존 B-Tree 에서 자식 노드가 최소 M/2 개의 데이터를 가져야 했던 점이 M*2/3 개로 바뀌었고,  
  노드가 가득 찼을 때 분열하지 않고 형제 노드로 재배치를 하게 된다는 차이점이 있다.

### 1-4. B+Tree
- B+Tree 는 B-Tree 의 확장 개념이다. B-Tree 의 경우 중간 노드들의 데이터에 key 와 value 를 남들 수 있지만,    
  B+Tree 의 경우 중간 노드에는 key 만 두고, value 는 담지 않는다.
- 오직 리프 노드에만 key 와 data 를 저장하고, 리프 노드기리는 Linked list 로 연결되는 방식이다.
- 이러한 방식의 장점은 리프 노드를 제외하면 value 를 담지 않기 때문에 메모리를 더 확보할 수 있다.
- 또한 트리의 높이 또한 낮아지게 되며, 탐색 시 리프 노드의 데이터만 살피므로 B-Tree 보다 탐색에 매우 유리하다.

<br>

## 2. 데이터베이스와 B-Tree
- 데이터베이스에서 어떤 데이터를 가져오려 하는 상황을 가정해보자. 이때 모든 데이터를 풀스캔으로 가져온다면 시간이 매우 오래 걸릴 것이다.
- 특히 데이터베이스 시스템은 디스크 기반이라 I/O 작업에서 상당한 시간을 소모한다.

### 3-1. B-Tree
- 빠른 데이터 액세스를 위해 여러 자료구조/알고리즘 논의가 있어왔고, B-Tree 는 그 중 가장 대표적인 구조이다.
- B-Tree 는 컬럼의 값과 해당 레코드가 저장된 주소 or 자식 노드 페이지 주소를 key:value 로 인덱스화 한다.
- B-Tree 는 이진 트리에서 파생된 트리 구조이다. 이진 트리와의 차이점이 있다면, 하나의 노드는 2개 이상의 데이터를 가질 수 있다는 점,
  그리고 자식 노드도 여러개를 가질 수 있다는 점이다.
- 이런 B-Tree 의 특성 덕분에 트리의 높이를 낮출 수 있게 되었다.
- 또한 이진 트리와 달리 B-Tree 는 균형된 트리의 모양을 갖추고 있다. 보통 트리를 이용한 탐색 복잡도는 O(logN)으로 알려져 있지만
  트리가 한쪽으로 쏠려있을 경우에는 O(n) 까지 성능이 저하된다.
- 그러나 B-Tree 는 INSERT, DELETE 같은 작업이 일어나도 항상 균형을 유지하도록 되어 있다. (그래서 Balanced Tree)

### 3-2. B-Tree 구조 규칙   
![image](https://github.com/user-attachments/assets/04fff15a-4737-4180-b830-e2e328cc7c7a)  
- 최상단의 노드를 root node, 최하단의 노드를 leaf node 그리고 그 사이 노드를 branch node 라고 부른다.
- 노드의 데이터 수는 두 개 이상일 수 있다.
- 노드의 데이터 수가 N개 이면, 자식 노드 수는 N+1개 여야 한다. (위 이미지처럼 데이터 수가 2개라면 자식 노드는 3개씩)
- 노드에 저장할 수 있는 데이터 수에 따라 M차 B-Tree 라 부른다.
- root 노드를 제외한 모든 노드는 적어도 M/2개의 데이터를 지니고 있어야 한다. (3차 B-Tree의 경우까지는 1개의 데이터 허용)
- 노드 내 키(key)는 정렬 된 상태어야 한다. (이진 트리와 동일한 규칙)
- leaf 노드로 가는 모든 경로는 그 길이가 같아야 한다. (트리 균형)

### 3-3. B-Tree의 한계
- B-Tree 의 가장 큰 단점은 **시퀀셜 엑세스**에 취약하다는 것이다.
- 우리는 데이터를 가져올 때 range 를 정해놓고 해당 range 에 속하는 데이터를 가져오는 작업을 종종한다.
- 아래와 같은 구조에서 1~5 범위를 조회하면, B-Tree 는 루트부터 하향식으로 데이터를 찾기 때문에 복잡할 수 밖에 없다.  
  ![image](https://github.com/user-attachments/assets/10b8ded4-b5e2-4e11-8960-cb4c58481500)
- 게다가 실제 데이터는 입력 순서대로 저장되어 있지도 않기 때문에 이렇게 흩뿌려져 있는 데이터를 정렬된 형태로 부여주는 작업은 매우 복잡하다.
- 추가적으로 노드의 삭제/삽입 작업이 이루어질 때 트리의 균형을 유지해주는 작업이 필수적이기 때문에 트리의 깊이에 따라 overhead가 커진다.

### 3-4. B+Tree
![image](https://github.com/user-attachments/assets/712a82cb-ef83-414b-b927-ce0f5316b4e3)  
- B+Tree 를 간단하게 표현한 다이어그램이다. 겉보기에는 큰 차이가 없어 보인다.
- 하지만 가장 하단의 leaf node 를 보면 같은 레벨의 노드들끼리 서로 linked list 형식으로 연결되어 있다.
- 시퀀셜 액세스를 효과적으로 처리하기 위해 key:value 페이지는 leaf node 에만 존재하고,
  그 외 레벨의 node 들은 오직 인덱싱을 하기 위한 key 를 저장하는 용도로만 사용된다.
####
![image](https://github.com/user-attachments/assets/35c3c77e-443e-4877-b5c0-d808c308ad87)  
- 위 다이어그램은 B+Tree 를 쉽게 풀어놓은 그림이다.
- leaf node 를 제외한 레벨의 노드들에는 더이상 data pointer(실제 데이터가 저장도니 주소 포인터)가 존재하지 않는다.
- 오직 leaf node 만이 실제 데이터를 가리킬 수 있기 때문에 모든 key 는 leaf level 에 존재해야 한다.
- 따라서 B-Tree 와 달리 부모 노드와 자식 노드가 같은 키를 공유할 수도 있다.
- 그리고 value 를 저장하지 않아서 남는 공간에 key 를 채워넣다 보니 트리의 높이를 낮출 수 있게 되었다.
- 이런 점들이 B+Tree 를 비교적 빠르고 효과적인 작업에 유리하게끔 한다.

### 3-5. 정리
|구분|B-Tree|B+Tree|
|----|----|----|
|데이터 포인터|모든 내부적인 노드들은 데이터 포인터를 지님|리프 노드에만 데이터 포인터가 존재|
|시퀀셜 액세스 탐색 방식|모든 key 가 리프 노드에 존재하지 않기 때문에 모든 노드를 탐색해야 함|모든 key 가 리프 노드에 존재하기 때문에 리프 레벨에서만 탐색하면 됨|
|키 중복 여부|모든 노드는 서로 다른 key 를 지님|부모 노드와 자식 노드가 같은 키를 가질 수 있음|
|삽입/삭제 복잡도|비교적 복잡함|비교적 간단함|
|링크드 리스트|존재하지 않음|리프 노드는 링크드 리스트로 연결되어 있음|
