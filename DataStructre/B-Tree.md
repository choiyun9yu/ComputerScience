# Balanced Tree

## 1. What is B Tree?
![image](https://github.com/user-attachments/assets/b18acceb-f0b0-40ad-9ca9-47a0c1fa9d74)
- B-Tree 는 데이터베이스와 파일 시스템에서 널리 사용되는 트리 자료구조의 일종이다.
- 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조이다.
- 즉, 하나의 노드에 하나의 데이터를 저장하는 다른 Self-Balanced Tree 와 달리,  
  하나의 노드에 여러개의 데이터를 저장하는 방식으로 Tree 의 height 를 줄여 탐색 시간을 더 획기적으로 줄이도로 고안되었다.
- 이렇게 고안된 트리를 유지하기 위한 몇가지 규칙이 있다.

### 1-1.B-Tree 규칙 
- 노드 안에 k 개의 데이터가 있다면 자식 노드 수는 k+1 개여야 한다.  
  ex) 첫번째 노드의 데이터 갯수를 2개로 잡았다면, 그 자식 노드의 수는 3개여야 한다.
- 노드 안 데이터는 정렬되어야 한다.  
  ex) 한 노드 안의 데이터는 오름차순으로 정렬되어야 한다.
- 자식 노드의 데이터는 부모 노드의 데이터에 따라 배치된다.  
  ex) 부모 노드의 데이터를 기준으로 자식 노드를 정렬하여 나눈다. 예시로 1 ~ 8의 값에 대해, 부모 노드의 데이터가 3,6이 들어간다면  
  ![image](https://github.com/user-attachments/assets/ba9fd9dc-5c0c-4e43-adb9-bf309a3813c4)    
  이런 형태로 자식 노드는 3보다 작은 값, 3과 6 사이 값, 6보다 큰 값으로 이루어진 3개의 자식 노드가 생긴다.
- 루트 노드가 리프 노드가 아닌 경우 항상 2개 이상의 자식을 갖는다.
- M차 B-Tree 라면 루트 노드와 리프 노드를 제외하고 최소 M/2개 이상의 데이터를 가지고 있어야 한다.  
  (최대 M 개의 자식을 가질 수 있는 B-Tree 를 M차 B-Tree 라고 한다.)
- 리프 노드의 데이터 수는 M 보다 작아야 한다. (리프 노드 최대 데이터 수는 M-1 개이다.)
- 모든 리프 노드의 높이는 같아야 한다.

  
### 1-2. B-Tree 의 연산
#### 탐색
- B-Tree 는 탐색 시 루트 노드에서부터 하향식으로 탐색한다.
- 자식 노드의 데이터는 부모 노드의 데이터에 따라 오름차순으로 배치되므로, 이를 활용한 대소비교를 통해 알맞은 브랜치를 따라 값을 찾을 때까지 하향하며 탐색한다.

#### 삽입
- B-Tree 의 삽입 과정은 탐색과 달리 리프 노드에서부터 상향식으로 찾이간다.
- 데이터를 넣을 적절한 리프 노드를 탐색하여 노드에 값을 삽입하면 되는데, 이때 주의할 점은 "리프 노드의 데이터 수는 M보다 작아야한다"를 만족시켜야 한다는 것이다.  
  노드에 들어있는 데이터 수가 M-2 이하라면 그냥 삽입하면 되지만, M-1 이라면 값이 삽입될 시 데이터 수가 M 이 되면서 B-Tree 의 조건을 위배하기 때문이다.  
  이 경우 해당 값을 부모 노드로 올리며 그 자식 노드들은 새로 분리해준다. 이 과정을 B-Tree 의 조건을 만족할 때까지 재귀적으로 수행한다.

#### 삭제 
- 노드를 삭제하는 과정은 조금 더 복잡한데, 삭제 시 B-Tree 의 조건인 아래 3가지를 만족하도록 트리를 재구조화 해야한다.
  - 루트 노드와 리프 노드를 제외한 노드는 2개 이상의 자식을 가져야 한다.
  - 각 노드는 M/2~ M-1 개의 데이터를 가질 수 있다.
  - 각 노드의 데이터 수가 k 라면 자식 노드의 수는 k+1 이어야 한다.
- 이때 경우에 따라 값이 삭제된 노드의 나머지 데이터를 분할하거나, 부모 노드로 올린 뒤 나머지 자식 노드를 B-Tree 의 조건에 맞게 재배치하는 작업이 필요하다.
- 만약 현재 노드와 자식 노드가 모두 데이터 수가 최소 인 경우, 트리의 높이를 줄여야할 수도 있다.
- 삭제된 데이터의 자식 노드를 합치고 부모 노드를 내려 이를 자식으로 연결하는 등의 재구조화가 필요하다.


### 1-3. B*Tree
- B*Tree 는 균형을 유지하기 위한 연산에서 노드의 생성과 부가적인 연산을 최소화하기 위해 등장하게 되었다.
- 기존 B-Tree 에서 자식 노드가 최소 M/2 개의 데이터를 가져야 했던 점이 M*2/3 개로 바뀌었고,  
  노드가 가득 찼을 때 분열하지 않고 형제 노드로 재배치를 하게 된다는 차이점이 있다.

### 1-4. B+Tree
- B+Tree 는 B-Tree 의 확장 개념이다. B-Tree 의 경우 중간 노드들의 데이터에 key 와 value 를 남들 수 있지만,    
  B+Tree 의 경우 중간 노드에는 key 만 두고, value 는 담지 않는다.
- 오직 리프 노드에만 key 와 data 를 저장하고, 리프 노드기리는 Linked list 로 연결되는 방식이다.
- 이러한 방식의 장점은 리프 노드를 제외하면 value 를 담지 않기 때문에 메모리를 더 확보할 수 있다.
- 또한 트리의 높이 또한 낮아지게 되며, 탐색 시 리프 노드의 데이터만 살피므로 B-Tree 보다 탐색에 매우 유리하다.
